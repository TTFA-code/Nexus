import { createClient } from '@/utils/supabase/server';
import { Database } from '@/types/supabase';

type TableName = keyof Database['public']['Tables'] | keyof Database['public']['Views'];

type Manifest = {
    [table: string]: string[];
};

const SCHEMA_MANIFEST: Manifest = {
    'lobby_players': ['status'],
    'lobbies': ['scheduled_start', 'notes', 'sector_key', 'creator_id'],
    'matches': ['id', 'game_mode_id', 'winner_team', 'approval_status'],
    'match_players': ['match_id', 'user_id', 'team']
};

export const SchemaSentinel = {
    /**
     * Checks if the database schema matches the locally defined manifest.
     * Returns a list of missing columns formatted as "table.column".
     */
    async checkSchemaSync(): Promise<{ synced: boolean; missing: string[] }> {
        const supabase = await createClient();
        const missing: string[] = [];

        // We'll iterate through the manifest and attempt a lightweight query for each column.
        // A more efficient way would be querying information_schema, but RLS might block it.
        // We'll try querying the actual tables with limit(0) and selecting the specific columns.
        // If it fails, we assume the column is missing.

        await Promise.all(
            Object.entries(SCHEMA_MANIFEST).map(async ([table, columns]) => {
                for (const column of columns) {
                    try {
                        // Attempt to select the specific column with no rows.
                        // "HEAD" request logic equivalent for DB.
                        const { error } = await supabase
                            .from(table as any)
                            .select(column)
                            .limit(0)
                            .maybeSingle();

                        if (error) {
                            // If error code indicates column missing (Postgres: 42703 usually, or PostgREST error)
                            // PostgREST usually returns 400 Bad Request if column doesn't exist
                            console.warn(`[SchemaSentinel] Probe failed for ${table}.${column}:`, error.message);
                            missing.push(`${table}.${column}`);
                        }
                    } catch (e) {
                        console.warn(`[SchemaSentinel] Exception for ${table}.${column}:`, e);
                        missing.push(`${table}.${column}`);
                    }
                }
            })
        );

        return {
            synced: missing.length === 0,
            missing
        };
    },
    /**
     * Generates a SQL patch string to fix missing columns.
     */
    generateMigrationPatch(missing: string[]): string {
        if (missing.length === 0) return "-- No missing columns detected.";

        const lines = ["-- Manual Migration Patch generated by SchemaSentinel"];

        missing.forEach(item => {
            const [table, column] = item.split('.');
            if (!table || !column) return;

            // Determine default type based on column name or common patterns
            let type = "TEXT";
            let def = "NULL";

            if (column === 'status') {
                type = "TEXT";
                def = "'pending'";
            } else if (column === 'scheduled_start') {
                type = "TIMESTAMPTZ";
                def = "NULL";
            } else if (column === 'notes') {
                type = "TEXT";
                def = "''";
            } else if (column === 'sector_key') {
                type = "TEXT";
                def = "NULL";
            } else if (column.endsWith('_id')) {
                type = "BIGINT"; // or UUID depending on schema, defaulting to BIGINT/UUID usually safe to check
            } else if (column === 'is_active') {
                type = "BOOLEAN";
                def = "true";
            }

            lines.push(`ALTER TABLE public.${table} ADD COLUMN IF NOT EXISTS ${column} ${type} DEFAULT ${def};`);
        });

        return lines.join('\n');
    }
};
